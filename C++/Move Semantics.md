# Move Semantics

객체에 이동 의미론을 적용하려면 이동 생성자와 이동 대입 연산자를 정의 해야 함   
그러면 컴파일러는 원본 객체가 임시 객체로 되어 있어서 연산을 수핸한 후 자동으로 제거되거나 사용자가 명시적으로 std::move()를 호출하여 삭제될 때 앞서 정의한 이동 생성자와 이동 대입 연산자를 이용   
즉, 메모리를 비롯한 리소스의 소유권을 다른 객체로 이동  
이 과정은 멤버 변수에 대한 얕은 복제와 비슷 
할당된 메모리나 다른 리로스에 대한 소유권을 전환함으로써 댕글링 포인터나 메모리 누수를 방지 
이동 생성재와 이동 대입 연산자는 원본 객체에 있는 데이터 멤버를 새 객체로 이동시키기 때문에 그 후 원본 객체는 정상이긴 하나 미확정된 상태로 남게됨  
이러한 원본 객체의 데이터 멤버를 널값으로 초기화하지만 꼭 그래야 하는것은 아님  
안전을 생각하면 이동되고 남은 객체를 사용하지 않는 것이 좋음    
std::unique_ptr과 std::shared_ptr은 예외    
이동 후에 남은 스마트 포인터를 다시 사용하는 일을 막기 위해 표준 라이브러리는 이러한 스마트 포인터를 이동하고 나서 반드시 내부적으로 nullptr로 초기화하도록 명시    

## 우측값 레퍼런스

좌측값이란 이름 있는 변수처럼 주소를 가질 수 있는 대상  
좌측값이라 부르는 이유는 대입문의 왼쪽에 나오기 때문    
우측값은 리터럴, 임시 객체, 값처럼 좌측값이 아닌 나머지     
우측값 레퍼런스는 우측값이 임시 객체이거나 std::move()로 명시적으로 이동된 객체일 때 적용   
오버로딩된 여러 함수 중에서 우측값에 대해 적용할 대상을 결정하는데 사용     
우측값 레퍼런스로 구현하면 크기가 큰 값(객체)을 복사하는 연산이 나오더라도 이 값이 나중에 삭제될 임시 객체라는 점을 이용하여 그 값에 우측값에 대한 포인터를 복사하는 방식으로 처리할 수 있음

함수의 매개변수에 &&를 붙여서 우측값 레퍼런스로 만들 수 있음
일반적으로 임시 객체는 const type&로 취급하지만 함수의 오버로딩 버전 중에서 우측값 레퍼런스를 사용하는 것이 있다면 그 버전으로 임시 객체를 처리
리터럴도 좌측값이 아니기 때문에 이때도 우측값 레퍼런스 버전이 호출(리터럴을 const 레퍼런스 매개변수에 대한 인수로 전달할 수는 있음)

좌측값 인수에 std::move()를 사용하여 컴파일러에 강제로 우측값 레퍼런스 버전의 함수를 호출하도록 만들 수 있음
move()는 좌측값 레퍼런스로 캐스트해주기만 함
실제로는 이동시키는 작업은 전혀 하지 않음
우측값 레퍼런스로 리턴하게 되면 컴파일러는 여러 가지 오버로드 버전 중에서도 이동 작업을 처리할 수 있는 우측값 레퍼런스를 인수로 받는 것을 찾음  

| 우측값 레퍼런스 매개변수와 같이 이름 있는 우측값 레퍼런스는 타입이 우측값 레퍼런스일 뿐 이름이 있으므로 매개변수 자체는 좌측값인 점에 주의

| 우측값 레퍼런스에 임시값을 대입하면 우측값 레퍼런스가 스코프에 있는 동안 계속 존재할 수 있음. 즉, 수명이 연장되는 효과가 발생

## 이동 의미론 구현 방법

클래스에 이동 의미론을 추가하려면 이동 생성자와 이동 대입 연산자를 구현해야 함
이때 이동 생성자와 이동 연산자를 noexcept로 지정해서 두 메서드에서 익셉션을 절대로 던지지 않는다고 컴파일러에 알려줘야 함
표준 라이브러리와 호환성을 유지하려면 이렇게 해야 함
표준 라이브러리 컨테이너의 완벽한 호환성 구현은 이동 의미론을 구현하고 익셉션도 던지지 않는다고 보장해야 저장된 객체를 이동시키기 때문

| 클래스에 소멸자, 복제 생성자, 이동 생성자, 복제 대입 연산자, 이동 대입 연사자 등과 같은 특수 멤버 함수를 하나 이상 선언했다면 일반적으로 이들 모두를 선언해야 함. 이를 5의 법칙이라 부름. 또한 이들 모두를 구현하거나 =default나 =delete로 명시적으로 디폴트로 만들거나 삭제해야 함

<utility>에 정의된 std::excahnge()는 기존 값을 새 값으로 교체한 후 기존 값을 리턴
이동 대입 연산자를 구현할 때 유용

