# Move Semantics

객체에 이동 의미론을 적용하려면 이동 생성자와 이동 대입 연산자를 정의 해야 함   
그러면 컴파일러는 원본 객체가 임시 객체로 되어 있어서 연산을 수핸한 후 자동으로 제거되거나 사용자가 명시적으로 std::move()를 호출하여 삭제될 때 앞서 정의한 이동 생성자와 이동 대입 연산자를 이용   
즉, 메모리를 비롯한 리소스의 소유권을 다른 객체로 이동  
이 과정은 멤버 변수에 대한 얕은 복제와 비슷 
할당된 메모리나 다른 리로스에 대한 소유권을 전환함으로써 댕글링 포인터나 메모리 누수를 방지 
이동 생성재와 이동 대입 연산자는 원본 객체에 있는 데이터 멤버를 새 객체로 이동시키기 때문에 그 후 원본 객체는 정상이긴 하나 미확정된 상태로 남게됨  
이러한 원본 객체의 데이터 멤버를 널값으로 초기화하지만 꼭 그래야 하는것은 아님  
안전을 생각하면 이동되고 남은 객체를 사용하지 않는 것이 좋음    
std::unique_ptr과 std::shared_ptr은 예외    
이동 후에 남은 스마트 포인터를 다시 사용하는 일을 막기 위해 표준 라이브러리는 이러한 스마트 포인터를 이동하고 나서 반드시 내부적으로 nullptr로 초기화하도록 명시    

## 우측값 레퍼런스

좌측값이란 이름 있는 변수처럼 주소를 가질 수 있는 대상  
좌측값이라 부르는 이유는 대입문의 왼쪽에 나오기 때문    
우측값은 리터럴, 임시 객체, 값처럼 좌측값이 아닌 나머지     
우측값 레퍼런스는 우측값이 임시 객체이거나 std::move()로 명시적으로 이동된 객체일 때 적용   
오버로딩된 여러 함수 중에서 우측값에 대해 적용할 대상을 결정하는데 사용     
우측값 레퍼런스로 구현하면 크기가 큰 값(객체)을 복사하는 연산이 나오더라도 이 값이 나중에 삭제될 임시 객체라는 점을 이용하여 그 값에 우측값에 대한 포인터를 복사하는 방식으로 처리할 수 있음

함수의 매개변수에 &&를 붙여서 우측값 레퍼런스로 만들 수 있음
일반적으로 임시 객체는 const type&로 취급하지만 함수의 오버로딩 버전 중에서 우측값 레퍼런스를 사용하는 것이 있다면 그 버전으로 임시 객체를 처리
리터럴도 좌측값이 아니기 때문에 이때도 우측값 레퍼런스 버전이 호출(리터럴을 const 레퍼런스 매개변수에 대한 인수로 전달할 수는 있음)

좌측값 인수에 std::move()를 사용하여 컴파일러에 강제로 우측값 레퍼런스 버전의 함수를 호출하도록 만들 수 있음
move()는 좌측값 레퍼런스로 캐스트해주기만 함
실제로는 이동시키는 작업은 전혀 하지 않음
우측값 레퍼런스로 리턴하게 되면 컴파일러는 여러 가지 오버로드 버전 중에서도 이동 작업을 처리할 수 있는 우측값 레퍼런스를 인수로 받는 것을 찾음  

| 우측값 레퍼런스 매개변수와 같이 이름 있는 우측값 레퍼런스는 타입이 우측값 레퍼런스일 뿐 이름이 있으므로 매개변수 자체는 좌측값인 점에 주의

| 우측값 레퍼런스에 임시값을 대입하면 우측값 레퍼런스가 스코프에 있는 동안 계속 존재할 수 있음. 즉, 수명이 연장되는 효과가 발생

## 이동 의미론 구현 방법

클래스에 이동 의미론을 추가하려면 이동 생성자와 이동 대입 연산자를 구현해야 함
이때 이동 생성자와 이동 연산자를 noexcept로 지정해서 두 메서드에서 익셉션을 절대로 던지지 않는다고 컴파일러에 알려줘야 함
표준 라이브러리와 호환성을 유지하려면 이렇게 해야 함
표준 라이브러리 컨테이너의 완벽한 호환성 구현은 이동 의미론을 구현하고 익셉션도 던지지 않는다고 보장해야 저장된 객체를 이동시키기 때문

| 클래스에 소멸자, 복제 생성자, 이동 생성자, 복제 대입 연산자, 이동 대입 연사자 등과 같은 특수 멤버 함수를 하나 이상 선언했다면 일반적으로 이들 모두를 선언해야 함. 이를 5의 법칙이라 부름. 또한 이들 모두를 구현하거나 =default나 =delete로 명시적으로 디폴트로 만들거나 삭제해야 함

### std::excahnge()

<utility>에 정의된 std::excahnge()는 기존 값을 새 값으로 교체한 후 기존 값을 리턴
이동 대입 연산자를 구현할 때 유용

### 갹체 데이터 멤버 이동하기

데이터 멤버가 객체일 때는 std::move()로 이동시켜야 함

vector는 객체를 추가할 때마다 동적으로 커짐
실행 중에 필요한 만큼 메모리를 추가로 할당해서 여기에 기존 vector에 있던 객체를 복제하거나 이동하기 때문
이떄 이동 생성자가 정의되어 있으면 컴파일러는 해당 객체를 복제하지 않고 이동시킴

## 이동 의미론으로 swap 함수 구현하기

    template <typename T>
    void swapMove(T&a, T& b)
    {
        T temp { std::move(a) };
        a = std::move(b);
        b = std::move(temp);
    }

## return 문에서 std::move() 사용하기
return object; 형식의 문장은 주어진 object가 로컬 변수거나, 함수에 대한 매개변수거나, 임싯값이라면 우측값 표현식으로 취급하면서 리턴값 최적화(return value optimization, RVO)가 적용
object가 로컬 변수일 때 이름 있는 리턴값 최적화(named return value optimization, NRVO)가 적용
RVO와 NRVO 둘 다 일종의 복제 생략으로서 함수에서 객체를 리턴하는 과정을 굉장히 효율적으로 처리
복제 생략을 적용하면 컴파일러는 함수에서 리턴하는 객체를 복제하거나 이동시킬 필요가 없음
이를 통해 영복제 값 전달 의미론(zero-copy pass-by-value semantics)을 구현할 수 있음

객체를 리턴하는데 std::move()를 사용하면 컴파일러는 RVO나 NRVO를 적용하지 않음
return object; 형식의 문장에만 적용되는 것이기 때문
객체가 이동 의미론을 지원할 경우에는 RVO 또는 NRVO의 차선책으로 이동 의미론을 적용하고, 그렇지 않으면 복제 의미론을 적용하는데 이렇게 되면 성능에 큰 타격을 입음

| 함수에서 로컬 변수나 매개변수를 리턴할 때는 std::move()를 사용하지 말고 그냥 return object;로 작성

RVO나 NRVO는 로컬 변수나 함수 매개변수에만 적용
따라서 객체의 데이터 멤버를 리턴할 때는 RVO나 NRVO가 적용되지 않음

    return condition ? object1 : object2;

return object; 형식의 문장은 아니므로 복제 생성자를 이용하여 하나를 리턴

RVO나 NRVO를 적용할 수 있는 컴파일러에 맞기 고쳐 쓰면 다음과 같음

    if (condition)
    {
        return object;
    }
    else
    {
        return ojbect2;
    }

조건 연산자를 꼭 써야 한다면 다음과 같이 작성할 수 있지만 이 때는 RVO나 NRVO가 적용되지 않고 이동 의미론이나 복제 의미론만 적용되는 사실을 명심

    return condition ? std::move(object1) : std::move(object2);

## 함수에 인수를 전달하는 최적의 방법

함수 매개변수가 기본 타입이 아닐 경우에는 함수로 전달하는 인수가 불필요하게 복제되지 않도록 const 레퍼런스를 사용
하지만 우측값이 섞인 경우에는 좀 다름

    class DataHolder
    {
        public:
            void setData(const std::vector<int>& data) { m_data = data; }
            void setData(std::vector<int>&& data) { m_data = std::move(data); }
        private:
            std::vector<int> m_data;
    };

setData()에 임싯값을 주고 호출하면 복제가 발생하지 않고 데이터를 이동

다음 코드는 const 레퍼런스 버전의 setData()를 호출, 따라서 데이터가 복제

    DataHolder wrapper;
    std::vector myData {11, 22, 33};
    wrapper.setData(myData);

setData()에 임싯값을 주고 호출하면 우측값 레퍼런스 버전이 호출

    wrapper.setData({22, 33, 44});

이런식으로 우측값과 좌측값 둘 다에 대해 setData()를 최적화하려면 오버로드 버전을 두 개 만들어야 함
복제되지 않을 매개변수에 대해서는 여전히 const 레퍼런스로 전달해야 함
값 전달 방식은 함수 안에서 어차피 복제하게 될 매개변수에만 적합함
이럴 때는 값 전달 방식을 적용하는 것이 좌측값과 우측값 모두에 대해 가장 효율적
좌측값이 전달되면 const 레퍼런스 매개변수와 마찬가지로 단 한번만 복제됨
또한 우측값이 전달될 경우에는 우측값 레퍼런스 매개변수처럼 복제가 전혀 발생하지 않는다

    class DataHolder
    {
        public:
            void setData(std::vector<int> data) { m_data = std::move(data); }
        private:
            std::vector<int> m_data;
    }

    setData()에 좌측값이 전달되면 data 매개변수로 복제된 후 m_data로 이동
    setData()에 우측값이 전달되면 data 매개변수로 이동한 후 다시 m_data로 이동

| 내부적으로 복제하는 함수에 대해서는 매개변수들 값 전달 방식으로 처리하지만 해당 매개변수는 이동 의미론을 지원하는 경우에만 그렇게 함. 나머지 경우는 const 레퍼런스 매개변수를 사용