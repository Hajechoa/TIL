# 메서드의 종류

## static 메서드

데이터 멤버에서 그랬던 것처럼 메서드도 객체 단위가 아닌 클래스 단위로 적용되는 것이 있음    
이를 static(정적, 스태틱) 메서드라 부르며 데이터 멤버를 정의하는 단게에 함께 작성함     
이들 메서드는 특정 객체에 대한 정보에 접근하지 않음     
따라 다음과 같이 static으로 정의할 수 있음  

    export class SpreadsheetCell
    {
        // 이전 코드 생략
        private:
            static std::string doubleToString(double value);
            static double stringToDouble(std::string_view value);
            // 나머지 코드 생략
    }

메서드 정의 앞부분에 static 키워드를 생략해도 됨    
하지만 static 메서드는 특정 객체에 대해 호출되지 않기 때문에 this 포인터를 가질 수 없으며 어떤 객체의 비 static 멤버에 접근하는 용도로 호출할 수 없다는 점을 명심해야 함    
static 메서드는 근본적으로 일반 함수와 비슷하지만 유일한 차이점은 클래스의 private static이나 protected static 멤버에 접근할 수 있다는 것   
참고로 타입이 같은 객체의 private 비 static이나 protected 비 static 메서드에서 접근하게 하는 방법은 있음    
예를 들어 객체를 포인터나 레퍼런스 타입의 매개변수로 전달하면 됨    

같은 클래스에 있는 메서드끼리는 static 메서드를 일반 함수처럼 호출할 수 있음    
따라서 SpreadsheetCell에 있는 메서드의 구현 코드는 고치지 않고 그대로 사용할 수 있음    

클래스 밖에서 호출할 때는 메서드 이름 앞에 스코프 지정 연산자(::)를 이용하여 클래스 이름을 붙여야 함    
접근 제한 방식도 일반 메서드와 똑같음   
예를 들어 Foo라는 클래스에 bar()라는 public static 메서드를 정의했다면 이 클래스 밖에서는 다음과 같은 형태로 호출해야 함    

    Foo::bar();

## const 메서드

const 객체란 값이 바뀌지 않는 객체를 말함   
객체나 객체의 레퍼런스 또는 포인터에 const를 붙이면 그 객체의 데이터 멤버를 절대 변강하지 않는다고 보장하는 메서드만 호출할 수 있음     
그렇지 않은 메서드를 호출하면 컴파일 에러가 발생    
이처럼 어떤 메서드가 데이터 멤버를 변경하지 않는다고 보장하는 표시를 하려면 해당 메서드 앞에 const 키워드를 붙임    
예를 들어 데이터 멤버를 변경하지 않는 메서드를 SpreadsheetCell 클래스에 추가하려면 다음과 같이 메서드를 const로 선언    

    export class SpreadsheetCell
    {
        public:
            // 이전 코드 생략
            double getValue() const;
            std::string getString() const;
            // 나머지 코드 생략
    };

const는 메서드 프로토타입의 일부분이기 때문에 다음과 같이 메서드를 정의하는 구현 코드에서도 반드시 적어야 함    

    double SpreadsheetCell::getValue(0 const
    {
        return m_value;
    }

    std::string SpreadsheetCell::getString() const
    {
        return doubleToString(m_value);
    }

메서드를 const로 선언하면 이 메서드 안에서 객체의 내부 값을 변경하지 않겠다고 클라이언트 코드와 계약을 맺는 것과 같음   
데이터 멤버를 수정하는 메서드를 const로 선언하면 컴파일 에러가 발생     
메서드에 const 키워드를 붙이면 그 메서드 안에서 각 데이터 멤버에 대한 const 레퍼런스를 가진 것처럼 작동     
따라서 데이터 멤버를 변경하는 코드가 나오면 컴파일 에러가 발생하는 것   

static 메서드는 const로 선언할 수 없음  
동어반복에 해당하기 때문    
static 메서드는 애초에 인스턴스를 가질 수 없으므로 인스턴스 내부의 값을 변경하는 것 자체가 말이 안 됨   

const로 선언하지 않는 객체에 대해서는 const 메서드와 비 const 메서드 둘 다 호출할 수 있음   
반면 객체를 const로 선언했다면 const 메서드만 호출할 수 있음    
예를 들면 다음과 같음   

    SpreadsheetCell myCell { 5 };
    cout << myCell.getValue() << endl;          // OK
    myCell.setString("6");                      // OK

    const SpreadsheetCell& myCellConstRef { myCell };
    cout << myCellConstRef.getValue() << endl;  // OK
    myCellConstRef.setString("6");              // 컴파일 에러가 발생한다.

코드를 작성할 때 객체를 수정하지 않는 메서드는 모두 const로 선언하는 습관을 들이면 좋음     
그러면 const 객체에 대한 레퍼런스를 사용할 수 있기 때문     

참고로 const 객체도 제거할 수 있으므로 소멸자도 호출될 수 있음  
하지만 소멸자를 const로 선언할 수는 없음    

### mutable 데이터 멤버

때로는 const로 정의한 메서드에서 객체의 데이터 멤버를 변경하는 경우가 있음  
변경하는 데이터가 사용자에게는 드러나지 않더라도 엄연히 수정 동작이기 때문에 이런 메서드를 const로 선언하면 컴파일 에러가 발생  
예를 들어 스프레드시트 애플리케이션에서 데이터를 읽는 빈도를 프로파일링하는 경우를 생각해보면   
가장 단순한 방법은 SpreadsheetCell 클래스에 카운터를 추가하고 getValue()나 getString()이 호출될 때마다 카운터를 업데이트하는 식으로 호출 횟수를 기록하는 것     
하지만 이렇게 하면 컴파일러 입장에서 볼 때 비 const 메서드가 되어버려서 const 객체로 만들 수 없게 됨    
이럴 때는 횟수를 세는 카운터 변수의 값을 수정할 수 있도록 mutable로 선언하면 const 메서드에서 변경해도 컴파일 에러가 발생하지 않음  
이렇게 SpreadsheetCell 클래스를 수정하면 다음과 같음    

    export class SpreadsheetCell
    {
        // 코드 생략
        private:
            double m_value { 0 };
            mutable size_t m_numAccesses { 0 };
    };

그리고 getValue()와 getString()을 다음과 같이 정의  

    double SpreadsheetCell::GetValue() const
    {
        m_numAccesses++;
        return m_value;
    }

    std::string SpreadsheetCell::getString() const
    {
        m_numAccesses++;
        return doubleToString(m_value);
    }

## 메서드 오버로딩

앞에서 한 클래스에 생성자를 여러 개 정의할 수 있다고 배웠음     
이렇게 정의한 생성자는 모두 이름은 같고 매개변수 타입이나 개수만 다름   
생성자가 아닌 메서드나 함수도 같은 이름으로 여러 개 정의할 수 있음  
이를 오버로딩이라 부름  
물론 이때도 마찬가지로 매개변수 타입이나 매개변수 개수는 서로 달라야 함     
예를 들어 다음과 같이 SpreadsheetCell 클래스에서 setString()과 setValue()를 모두 set()으로 통일할 수 있음   

    export class SpreadsheetCell
    {
        public:
            void set(double value);
            void set(std::string_view value);
    };

set() 메서드의 구현 코드는 수정할 필요 없음     
컴파일러는 set()을 호출하는 코드를 발견하면 매개변수 정보를 참고하여 어느 버전의 set()을 호출할지 결정  
매개변수가 string_view 타입이면 string_view 버전의 set()을 호출하고, 매개변수가 double 타입이면 double 버전의 set()을 호출  
이를 오버로딩 결정(overloading resolution)이라 부름 

getValue() getString() 메서드도 마찬가지로 get()으로 통일하고 싶을 수도 있음    
하지만 여기에서는 오버로딩을 적용할 수 없음     
C++에서는 메서드의 리턴 타입만 다른 형식의 오버로딩은 지원하지 않음     
그 정보만으로는 호출할 메서드의 버전을 정확히 결정할 수 없는 경우가 많기 때문   
예를 들어 메서드의 리턴값이 드러나는 문장이 하나도 없으면 컴파일러 입장에서는 어느 버전을 호출하는지 알 방법이 없음