# C++20 이전의 스트링 포맷

## C 함수

* 안전하지 않고 커스텀 타입을 지원하도록 확장 할 수 없기 때문에 비권장
* 포맷 스트링과 인수가 분리되어 있어서 읽기 쉬움
* 예: printf("x has value %d and y has value %d. \n", x, y);

## C++ I/O 스트림

* 타입에 안전하고 확장할 수 있어서 (C++20 이전 버전에서) 권장하는 방법
* 스트링과 인수가 섞여 있어서 읽기 힘듬
* 예: cout << "x has value " << x << " and y has value " << y << endl;

# Header

\<format>

# std::format()

format()의 첫 번쨰 인수는 포맷 지정 스트링
그 뒤에 나오는 인수는 포맷 지정 스트링에 있는 빈 칸에 채워질 값
format()에서 빈 칸을 항상 빈 중괄호({})로 표기
중괄호({})에 들어갈 스트링은 [index][:specifier] 형식으로 지정
모든 빈 칸에 index를 생략해도 되고, 모든 빈 칸에 대해 0부터 시작하는 인덱스 값을 두 번째 인수부터 필요한 만큼 지정할 수도 있음
인덱스를 생략하면 format()의 두 번째 인수부터 나오는 값을 빈 칸 순서대로 집어 넣음
specifier는 주어진 값을 출력할 때 따를 형식을 변경하는 포맷 지정자

    auto s1 { format("Read {} bytes from {}", n, "file1.txt") };
    auto s2 { format("Read {0} bytes from {1}", n, "file1.txt") };

인덱스를 직접 지정하는 방법과 자동으로 인덱스를 지정하는 방법을 혼용할 수 없음

    auto s2 { format("Read {0} bytes from {}", n, "file1.txt") };

출력 스트링에 포맷이 적용되어 나오는 순서는 format()에 인수를 전달하는 순서를 변경하지 않고도 변경 가능

    auto s3 { format("Read {1} bytes from {0}", "file1.txt", n) };

## 포맷 지정자

포맷 지정자는 값을 출력할 때 적용할 포맷을 설정
앞에 콜론(:)이 붙으며, 일반적으로 다음과 같은 형식으로 표기
    
    [[fill]align][sign][#][0][width][.precision][type]

대괄호 안에 나오는 부분은 모두 선택사항

### width

주어진 값의 포맷을 적용할 필드의 최소 폭을 지정
이 값을 중괄호 집합으로 표기해도 되는데, 이를 동적 폭이라 부름

    int i { 42 };
    cout << format("|{:5}|", i) << endl;        //|   42|
    cout << format("|{:{}}|", i, 7) << endl;    //|     42|

### [fill]align

채울 문자와 해당 필드에 값이 정렬되는 방식을 지정
* <: 왼쪽 정렬(정수나 부동소수점수가 아닌 값에 기본 적용)
* \>: 오른쪽 정렬(정수나 부동소수점수에 기본 적용)
* ^: 가운데 정렬

출력될 때 [width]로 지정한 최소 폭에 맞게 채울 문자가 적용
[width]를 지정하지 않았다면 [fill]align이 적용되지 않음

    int i { 42 };
    cout << format("|{:7}|", i) << endl;        // |     42|
    cout << format("|{:<7}|", i) << endl;       // |42     |
    cout << format("|{:_>7}|", i) << endl;      // |_____42|
    cout << format("|{:_^7}|", i) << endl;      // |__42___|

### \#

\#은 얼티네이트 포매팅 규칙을 제공
정수 타입과 16진수, 2진수, 8진수 숫자 포맷 지정에 대해 적용할 경우 0x, 0X, 0b, 0B, 0등을 숫자 앞에 붙임
부동소수점 타입에 적용할 경우 뒤에 나온느 숫자가 없더라도 10진 구분자를 출력