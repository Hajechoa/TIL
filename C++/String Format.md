# C++20 이전의 스트링 포맷

## C 함수

* 안전하지 않고 커스텀 타입을 지원하도록 확장 할 수 없기 때문에 비권장
* 포맷 스트링과 인수가 분리되어 있어서 읽기 쉬움
* 예: printf("x has value %d and y has value %d. \n", x, y);

## C++ I/O 스트림

* 타입에 안전하고 확장할 수 있어서 (C++20 이전 버전에서) 권장하는 방법
* 스트링과 인수가 섞여 있어서 읽기 힘듬
* 예: cout << "x has value " << x << " and y has value " << y << endl;

# Header

\<format>

# std::format()

format()의 첫 번쨰 인수는 포맷 지정 스트링
그 뒤에 나오는 인수는 포맷 지정 스트링에 있는 빈 칸에 채워질 값
format()에서 빈 칸을 항상 빈 중괄호({})로 표기
중괄호({})에 들어갈 스트링은 [index][:specifier] 형식으로 지정
모든 빈 칸에 index를 생략해도 되고, 모든 빈 칸에 대해 0부터 시작하는 인덱스 값을 두 번째 인수부터 필요한 만큼 지정할 수도 있음
인덱스를 생략하면 format()의 두 번째 인수부터 나오는 값을 빈 칸 순서대로 집어 넣음
specifier는 주어진 값을 출력할 때 따를 형식을 변경하는 포맷 지정자

    auto s1 { format("Read {} bytes from {}", n, "file1.txt") };
    auto s2 { format("Read {0} bytes from {1}", n, "file1.txt") };

인덱스를 직접 지정하는 방법과 자동으로 인덱스를 지정하는 방법을 혼용할 수 없음

    auto s2 { format("Read {0} bytes from {}", n, "file1.txt") };

출력 스트링에 포맷이 적용되어 나오는 순서는 format()에 인수를 전달하는 순서를 변경하지 않고도 변경 가능

    auto s3 { format("Read {1} bytes from {0}", "file1.txt", n) };

## 포맷 지정자

포맷 지정자는 값을 출력할 때 적용할 포맷을 설정
앞에 콜론(:)이 붙으며, 일반적으로 다음과 같은 형식으로 표기
    
    [[fill]align][sign][#][0][width][.precision][type]

대괄호 안에 나오는 부분은 모두 선택사항

### width

주어진 값의 포맷을 적용할 필드의 최소 폭을 지정
이 값을 중괄호 집합으로 표기해도 되는데, 이를 동적 폭이라 부름

    int i { 42 };
    cout << format("|{:5}|", i) << endl;        //|   42|
    cout << format("|{:{}}|", i, 7) << endl;    //|     42|

### [fill]align

채울 문자와 해당 필드에 값이 정렬되는 방식을 지정
* <: 왼쪽 정렬(정수나 부동소수점수가 아닌 값에 기본 적용)
* \>: 오른쪽 정렬(정수나 부동소수점수에 기본 적용)
* ^: 가운데 정렬

출력될 때 [width]로 지정한 최소 폭에 맞게 채울 문자가 적용
[width]를 지정하지 않았다면 [fill]align이 적용되지 않음

    int i { 42 };
    cout << format("|{:7}|", i) << endl;        // |     42|
    cout << format("|{:<7}|", i) << endl;       // |42     |
    cout << format("|{:_>7}|", i) << endl;      // |_____42|
    cout << format("|{:_^7}|", i) << endl;      // |__42___|

### \#

\#은 얼티네이트 포매팅 규칙을 제공
정수 타입과 16진수, 2진수, 8진수 숫자 포맷 지정에 대해 적용할 경우 0x, 0X, 0b, 0B, 0등을 숫자 앞에 붙임
부동소수점 타입에 적용할 경우 뒤에 나온느 숫자가 없더라도 10진 구분자를 출력

#### Type

type은 주어진 값을 반드시 따라야 할 타입을 지정
* 정수 타입: b(2진수), B(2진수, #을 지정했다면 0b 대신 0B 적용), d(10진수), o(8진수), x(16진수, 소문자 a, b, c, d, e, f 사용)
* 부동소수점 타입
    * e, E: e나 E로 지수를 표현하는 과학 표기법, 지정한 정밀도가 없으면 6을 적용
    * f, F: 고정 표기법, 정밀도가 없으면 6을 적용
    * g. G: e나 E로 지수를 표현하는 일반 표기법, 지정한 정밀도가 없으면 6을 적용
    * a, A: a나 A로 16진수를 표현
    * 타입을 지정하지 않으면 부동소수점 타입에 대해 g가 적용
* 부울 타입: s(텍스트 형식에서는 true나 false 출력), 정수 형식에서는 1이나 0을 출력, 타입을 지정하지 않으면 부울 타입에 대해 s가 적용
* 문자 타입: c(출력할 때 문자가 복제됨), 정수 표현, 타입을 지정하지 않으면 문자 타입에 대해 c가 적용
* 스트링 타입: s(출력할 때 스트링이 복제됨), 타입을 지정하지 않으면 스트링 타입에 대해 s가 적용
* 포인터 타입: p(0x로 시작하는 16진수 표기법), 타입을 지정하지 않으면 포인터 타입에 대해 p가 적용

### precision

부동소수점과 스트링 타입에만 적용   
부동소수점 타입을 표기할 때는 점(.)을 먼저 붙이고 그 뒤에 10진수 숫자를 적고, 스트링을 표기할 때는 점 뒤에 문자 개수를 적음     
width와 마찬가지로 중괄호로 표기할 수 있으며, 이를 동적 정밀도라고 함
format()에 지정한 인수 목록에서 다음 번째 인수를 적용하거나 별도로 지정한 인덱스가 있다면 해당 인수를 적용

    double d { 3.1415 / 2.3 };
    cout << format("{:12g}", d) << endl;                            // |    1.365870|
    cout << format("{:12.2}", d) << endl;                           // |        1.37|
    cout << format("{:12e}", d) << endl;                            // |1.365870e+00|
    
    int width { 12 };
    int precision { 3 };
    cout << format("|{2:{0}.{1}f}|", widthm precision, d) << endl;  // |       1.366|

#### 0

숫잣값에 대해 적용할 때 [width]로 지정한 최소 폭에 맞게 0을 집어넣음

    int i { 42 };
    
    cout << format("|{:06d}|", i) << endl;  // |000042|
    cout << format("|{:+06d}|", i) << endl; // |+00042|
    cout << format("|{:06X}|", i) << endl;  // |00002A|
    cout << format("|{:#06X}|", i) << endl; // |0X002A|
