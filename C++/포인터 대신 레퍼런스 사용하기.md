# 포인터 대신 레퍼런스 사용하기

C++ 프로그래머는 C 언어를 쓰다가 넘어온 경우가 많음     
C에서는 레퍼런스 전달 방식을 사용하려면 포인터를 사용하는 수밖에 없었음     
이것만으로도 그 동안 문제 없이 프로그램을 작성했음  
C++에서는 반드시 포인터를 사용해야 하는 경우가 있지만 대부분 레퍼런스로 처리할 수 있음  
C 언어부터 배운 사람이라면 레퍼런스가 추가되었다고 해서 특별히 달라질 것이 없어 보일 수 있음    
그저 포인터가 제공하던 기능에 새로운 문법만 추가된 것이라 여기기 쉬움   

포인터 대신 레퍼런스를 사용하면 좋은 점이 많음  
첫째, 포인터보다 레퍼런스가 더 안전     
메모리 주소를 직접 다루지 않고, nullptr이 될 수 없기 때문   
둘째, 코딩 스타일 측면에서 포인터보다 레퍼런스를 사용하는 것이 더 나음  
스택 변수와 문법이 같아서 *나 &와 같은 기호를 쓸 필요가 없기 때문   
또한 사용법도 간단해서 레퍼런스에 관련된 스타일 규칙을 따로 마련할 필요가 없음  
그럼에도 불구하고 아직까지도 함수를 호출할 때 &를 붙이면 함수 안에서 해당 객체를 변경하고,  
 &가 없으면 값으로만 전달한다고 여기는 프로그래머가 꽤 있음     
레퍼런스를 사용하면 함수 프로토타입을 보지 않고서는 그 함수에 전달된 객체가 변경되는지 알 수 없다고 주장하는데 그렇지 않음  
포인터를 전달한다고 해서 그 객체가 항상 수정되는 것은 아님  
예를 들어 매개변수를 const T*로 지정하는 경우도 있음    
포인터와 레퍼런스를 모두 전달하더라도 그 객체를 수정할 수도 있고, 그렇지 않을 수도 있음     
함수 프로토타입에서 const T*, T*, const T&, T& 중 어느 것으로 지정하느냐에 따라 결정됨  
따라서 함수에서 객체를 수정하는지 알아내려면 어차피 함수 프로토타입을 봐야 함   

레퍼런스의 또 다른 장점은 메모리의 소유권을 명확히 표현할 수 있다는 것  
다른 프로그래머가 전달한 객체를 레퍼런스로 받도록 메서드를 작성하면 그 객체를 읽거나 수정하는 작업은 마음껏 할 수 있지만,   
전달된 객체에 할당된 메모리를 해제하기는 쉽지 않음  
하지만 포인터로 전달하면 그렇지 않음    
객체를 삭제해서 메모리를 해제하는 코드를 메서드 안에 넣어야 할지 아니면 이 작업은 호출한 측에서 처리할지 명확히 정해진 바가 없음    
참고로 모던 C++에서 메모리를 다룰 때는 스마트 포인터를 사용하는 것이 좋음   